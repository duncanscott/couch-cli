apply plugin: 'groovy'
apply plugin: 'maven'
apply plugin:'application'

sourceCompatibility = 1.7
mainClassName = 'net.duncanscott.couch_cli.client.CouchClient'

task wrapper(type:Wrapper) {
	gradleVersion = '1.11'
}

jar {
	manifest {
		attributes 'Implementation-Title': 'Couch-Cli', 'Implementation-Version': version
	}
}

repositories {
	mavenCentral()
}

dependencies {
	compile 'org.codehaus.groovy:groovy-all:2.2.2'
	compile 'log4j:log4j:1.2.17'
	compile 'org.codehaus.groovy.modules.http-builder:http-builder:0.7'
	compile 'commons-cli:commons-cli:1.2'
	
	testCompile "org.spockframework:spock-core:0.7-groovy-2.0"	
}

configurations {
	unitTestCompile.extendsFrom testCompile
	unitTestRuntime.extendsFrom testRuntime
	integrationTestCompile.extendsFrom testCompile
	integrationTestRuntime.extendsFrom testRuntime
}

sourceSets {
	main {
		groovy {
			srcDir 'src/main/groovy'
		}
		resources {
			srcDir 'src/main/resources'
		}
	}
	unitTest {
		groovy {
			srcDir 'src/test/unit/groovy'
		}
		resources {
			srcDir 'src/test/unit/resources'
		}
		compileClasspath += sourceSets.main.output
		runtimeClasspath = output + compileClasspath
	}
	integrationTest {
		groovy {
			srcDir 'src/test/integration/groovy'
		}
		resources {
			srcDir 'src/test/integration/resources'
		}
		compileClasspath += sourceSets.main.output
		runtimeClasspath = output + compileClasspath
	}
}

processResources {
	filter { String line ->
		def matcher = line =~ /<%([^%]+)%>/
		matcher?.eachWithIndex { match, Integer index ->
			String prop = matcher[index][1]?.trim()
			String value  = project.properties[prop]
			if (value == null) {
				throw new RuntimeException("no property defined for substitution variable ${matcher[index][0]}")
			}
			line = matcher.replaceAll(value)
		}
		return line
	}
}

task unitTest(type:Test) {
	binResultsDir = file("$buildDir/$name-results/binary")
	reports {
		html.destination = file("$buildDir/reports/$name")
		junitXml.destination = binResultsDir.parentFile
	}
	classpath = sourceSets.unitTest.runtimeClasspath
	testClassesDir = sourceSets.unitTest.output.classesDir
}

task integrationTest(type:Test) {
	mustRunAfter unitTest
	binResultsDir = file("$buildDir/$name-results/binary")
	reports {
		html.destination = file("$buildDir/reports/$name")
		junitXml.destination = binResultsDir.parentFile
	}
	classpath = sourceSets.integrationTest.runtimeClasspath
	testClassesDir = sourceSets.integrationTest.output.classesDir
}

test.dependsOn integrationTest, unitTest

tasks.withType(Test) { testTask ->
	afterTest { TestDescriptor descriptor, TestResult result ->
		long duration = result.endTime - result.startTime
		String logMessage = "${result.resultType} (${duration} msecs): ${testTask.name} ${descriptor.className} \"${descriptor.name}\""
		switch (result.resultType) {
			case TestResult.ResultType.SUCCESS:
				logger.info "${logMessage}"
				break;
			case TestResult.ResultType.FAILURE:
				logger.error "${logMessage}"
				break;
			case TestResult.ResultType.SKIPPED:
				logger.warn "${logMessage}"
				break;
			default:
				logger.warn "${logMessage}"
		}
	}
}

task projectProperties {
	group 'properties'
	description 'output project.properties'
	doLast {
		project.properties.keySet().sort().each { key ->
			println "${key}=${project.properties[key]}"
		}
	}
}

task gradleProperties {
	group 'properties'
	description 'output gradle.properties'
	doLast {
		gradle.properties.keySet().sort().each { key ->
			println "${key}=${gradle.properties[key]}"
		}
	}
}

task projectConfigurations {
	group 'properties'
	description 'output project.configurations'
	doLast {
		project.configurations.sort{ it.name }.each { Configuration config ->
			println "${config.name}"
		}
	}
}

task gradleVersion {
	group 'properties'
	description 'output project.properties[gradleVersion]'
	doLast {
		println "gradleVersion=${gradle.properties['gradleVersion']}"
	}
}
